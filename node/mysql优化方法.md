# mysql 的优化方法
## MYSQL 逻辑结构
MySQL逻辑架构整体分为三层，最上层为客户端层，并且MySql所独有，诸如：连接处理、授权认证、安全等功能均在这一层处理。  

MySQL 大多数核心服务均在中间一层，包括查询解析、分析、优化、缓存、内置函数（比如：时间、数学、加密等函数）。所有的跨存储引擎的功能也在这一层实现：存储过程、
触发器、视图等。  

最下层为存储引擎，其负责MySQL 中的数据存户与提取，和Linux 下的文件系统类似，每种存储引擎都有其优势和劣势。中间的服务层通过API与存储引擎通信，这些API接口屏蔽了不同
存储引擎间的差异。  

## Mysql 查询过程  
我们总是希望MYSQL能够获得更高的查询性能，最好的办法是弄清楚MSYQL 是如何优化和执行查询的。一旦理解了这一点，就会发现：很多擦查询优化工作实际上就是遵循了一些原则让MYSQL的优化器能够按照预想的合理方式运行而已。  


### 客户端/服务端 通信协议
MYSQL 客户端/服务端通信协议是半双工的：在任一时刻，要么是服务器间向客户端发送数据，要么事客户端向服务器发送数据，这两个动
作不能同时发生，一旦一端开始发送信息，另一端要接收向服务器发送数据，这两个动作不能同时发生，一旦一端开发发送信息，另一端
要接收完整个信息才能响应它，所以我们无法也无须将要给消息切成小块独立发送，也没有办法进行流量控制。    

客户端用一个单独的数据包将查询请求发送给服务器，所以当查询语句很长的时候，需要设置 max_allowed_packet参数，但是，需要注意的是，
如果查询实在太大，服务端会拒绝接收更多数据并抛出异常。  

与之相反的是，服务器响应给用户的数据通常会很多，由多个数据包组成，但是当服务器响应客户端请求时，客户端必须完整的接收整个返回
结果，而不能简单的只取前面几条数据，然后让服务器停止发送，因而在实际开发中，尽量保持查询简单且只返回必需的数据，减少通信间
数据包的大小和数量是一个非常好的习惯，这也是查询中尽量避免使用SELECT * 以及加上limit 限制的原因之一。  

### 查询缓存
在解析一个查询语句前，如果查询缓存是打开的，那么MYSQL 会检查这个查询语句是否命中查询缓存中的数据。如果当前查询恰好命中查询缓存，在
检查一次用户权限后直接返回缓存中的结果。这种情况下，查询不会被解析，也不会生成执行计划，更加不会执行。  

MYSQL 将缓存存放在一个引用表（不要理解成table，可以认为是类似与HashMap的数据结构），通过一个哈希值索引，这个哈希值通过查询本身，当前要查询的数据库、客户端
协议版本号等一些可能影响结果的信息计算得来。所以两个查询在任何字符上的不同，都会导致缓存不会命中。  

如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、mysql库中的系统表，其查询结果都不会被缓存。比如函数NOW()或者CURRENT_DATE()会因为不同的查询时间，
返回不同的查询结果，再比如博阿寒CURRENT_USER 或者 CONNECION_ID()的查询语句会因为不同的用户而返回不同的结果，将这样的查询结果缓存起来没有任何意义。  

既然是缓存，就会失效，那查询缓存何时失效呢？MYSQL的查询缓存系统会跟踪查询中涉及的每个表，如果这些表（数据或者结构）发生变化，那么和这张表相关的所有缓存数据都将
失效，正因为如此，在任何的写操作是，MYSQL必须将对应表的所有缓存都设置为失效。如果查询缓存非常大或者碎片很多，这个操作就可能带来很大的系统消耗，甚至导致系统僵死。而且
查询缓存系统的额外消耗也不仅仅在写操作，读操作也不例外；  

1 任何的查询语句在开始之前都必须经过检查，即使这条SQL语句永远不会命中缓存。  

2 如果查询结果可以被缓存，那么执行完成后，会将结果存入缓存，也会带来额外的系统消耗。  

基于此，我们要知道并不是什么情况下查询缓存都会提高系统性能，缓存和失效都会带来额外消耗，只有当缓存带来的资源节约大于其本身消耗的资源时，才会给系统带来性能提升。
但是要如何评估打开缓存是否能够带来性能提升是一件非常困难的事情。如果系统确实存在一些性能问题，可以尝试打开查询缓存，并在数据库设计上做一些优化。比如：  
1、用多个小表代替一个大表，注意不要过度设计  
2、批量插入代替循环单条插入  
3、合理控制缓存空间大小，一般来说其大小设置为几十兆比较合适。  
4、可以通过SQL_CASH、SQL_NO_CASH 来控制某个查询语句是否需要进行缓存。  
不要轻易打开查询缓存，特别时写密集型应用，如果你实在忍不住，可以将 query_cache_type 设置为 DEMAND ,这时只有加入 SQL_CACHE 的查询才会走缓存，
其他查询则不会，这样可以非常自由地控制哪些查询需要被缓存。  

### 语法解析和预处理  
MYSQL 通过关键字将SQL语句进行解析，并生成一颗对应地解析树，这个过程解析器主要通过语法规则来验证和解析。比如SQL中是否使用了错误地关键字或者关键字的顺序是否正确等等。
预处理则会根据MYSQL 规则进一步检查解析树是否合法，比如检查要查询的数据表和数据列是否存在等等。  

### 查询优化
经过前面的步骤生成的语法树被认为是合法的了，并且由优化器将其转化成查询计划，多数情况下，一条查询可以有多种执行方式，最后都返回相应的结果，优化器的作用就是找到
这其中最好的执行计划。  

MYSQL 使用基于成本的优化器，它尝试预测一个查询使用执行计划成本，并选择其中成本最小的一个，在MYSQL 可以通过查询当前会话的 last_query_cost 的 值来得到其计算当前查询
的成本  

示例中的结果表示优化器大概需要做6391个数据也得随机查找才能完成上面得查询。这个结果是根据一些列得统计信息计算得来的，这些统计信息包括：每张表或者索引得也买你个数、
索引得基数、索引和数据行的长度、索引的分布情况等等。  

有非常多的原因会导致MYSQL 选择错误的执行计划，比如统计信息不准确，不会考虑 不受其控制的操作成本（用户自定义函数、存储过程）、MYSQL 认为的最优跟我们想的不一样（我们
希望执行时间尽可能短，但MYSQL值选择它认为成本小的，但成本小并不意味着执行时间短等）  

MYSQL 的查询优化器是一个非常复杂的部件，它使用了非常多的优化策略来生成一个最优的执行计划：  
重新定义表的关联顺序（多张表关联查询时，并不一定按照SQL中指定的顺序进行，但是有一些技巧可以指定关联顺序）  

优化MIN()和MAX()函数（找某列的最小值，如果该列有索引，只需要查找B+Tree索引最左端，反之则可以找到最大值，）  

提前终止查询（比如：使用Limit 时，查找到满足数量的结果集后立即终止查询）  

优化排序（在老版本MYSQL 会使用两次传输排序，即先读取行指针和需要排序的字段在内存中对其排序，然后再根据排序结果去读取数据行，而新版本采用的是单词传输排序，也就是一次读取多有的数据
行，然后根据给定的列排序。对于I/O密集型应用，效率会高很多）  

### 查询执行引擎  
再完成解析和优化阶段以后，MYSQL 会生成对应的执行计划，查询执行引擎根据执行计划给出的指令逐步执行得出结果。整个执行过程的大部分操作均是通过调用存储引擎实现的接口来完成，这些
接口被称为handler API。查询过程中的每一张表由一个handler 实例表示。实际上，MYSQL再查询优化阶段就为每一张表创建了handler实例，优化器根据这些实例的接口来获取表的向相关信息，包括
表的所有列名、索引统计信息等。存储引擎接口提供了非常丰富的功能，但其底层仅有几十个接口，这些接口像答积木一样完成了一次查询的大部分操作。 

### 返回结果给客户端 
查询执行的最后一个阶段就是将结果返回给客户端，即使查询不到数据。MYSQL 仍然会返回这个查询的相关信息，比如该查询影响到的行数以及执行时间等等。  

如果查询缓存被打开且这个查询可以被缓存，MYSQL 也会将结果放到缓存中。  

结果集返回给客户端是一个增量且逐步返回的过程，有可能MYSQL 在生成第一条结果时，就开始向客户端逐步返回结果集了，这样服务端就无需存储太多结果而消耗过多内存，也可以让客户端第一时间
获得返回结果。需要注意的是，结果集中的每一行都会以一个满足 （1）中所描述的通讯协议的数据包发送，再通过TCP协议进行传输，再传输过程中，可能会对MYSQL的数据包进行缓存然后批量发送。  
 MYSQL 整个查询执行过程，总的来说分为6个步骤：  
 1 客户端向MySQL服务器发送一条查询请求  
 2 服务器首先检查查询缓存，如果命中缓存，则立刻返回存储再缓存中的结果。否则进入下一个阶段。  
 3 服务器进行SQL解析、预处理、再由优化器生成对应的执行计划。  
 4 MYSQL 根据执行计划，调用存储引擎的API来执行查询。  
 5 将结果返回给客户端，同时缓存查询结果  
 
 ### 性能优化建议  
 
 ##### scheme设计与数据库类型优化
 选择数据库类型只要遵循小而简单的原则就好，越小的数据类型通常会更快，占用更少的磁盘、内存、处理时需要的CPU周期也更少，越简单的数据类型再计算时需要更少的CPU周期，
 比如整型就比字符操作代价低，因而会使用整形来存储IP地址，使用DATETIME 来存储时间，而不是使用字符串。  
 
 这里总结几个可能容易理解错误的技巧：
 1 通常说把可为null的列改为not null 不会对性能提升多少帮助，只是如果计划再列上创建索引，就应该将该列设置为not null。  
 
 2 对整数类型指定宽度，比如 INT(11),没有任何作用。int使用32为（4个字节）存储空间，那么它的表示范围已经确定，所以INT(11)和INT(20)对于存储和计算时相同的。  
 
 3 UNSIGNED 表示不允许负值，大致可以使整数的上限提高一倍。比如TINYINT 存储范围使-128~127，而UNSIGNED TINYINT 存储的范围却是 0-255
 
 4 通常来讲，没有太大的必要使用DECIMAL数据类型，即使是在存储财务数据时，仍然可以使用BIGINT。比如需要精确到万分之一，那么可以将数据乘以一百后然后使用BIGINT存储，
 这样可以避免浮点数计算不准确和DECIMAL 精确计算代价高的问题。  
 
 5 TIMESTAMP 使用 4个字节存储空间，DATETIME使用8个字节存储空间，因而TIMESTAMP只能表示 1970 - 2038 年，比DATETIME 表示的范围小得多，而且TIMESTAMP 的值因时区不同而不同。  
 
 6 大多数情况下没有使用枚举类型的必要，其中一个缺点时枚举的字符串列表是固定的，添加和删除字符串（枚举选项），然后再服务器层将缓冲内容解码成各个列，这个转换过程的 代价是非常
 高的，如果列太多而实际使用的列又很少的话，有可能导致CPU占用过高。  
 
 7 schema 的列不要太多，原因是存储引擎的API工作时需要再服务器层和存储引擎层之间通过缓冲格式拷贝数据，然后再服务器层将缓冲内容解码成各个列，这个转换过程的代价非常高，
 如果列太多而实际使用的列又很少的话，有可能导致CPU占用过高。  
 
 8 大表ALTER TABLE 非常耗时，MYSQL 执行部分修改表结果操作的方法使用新的结构创建一张空标，从旧表中查出所有的数据插入新表，然后再删除旧表，尤其当内存不足而表有很大，
 而且还有很大索引的情况下，耗时更久。  
 
 ### 创建高性能索引  
 索引是提高MYSQL 查询性能的一个重要途径，但过多的索引可能会导致过高的磁盘使用率以及过高的内存占用，从而影响应用程序的 整体性能，应当尽量避免事后才想起添加索引， 
 因为事后可能需要监控大量的SQL才能定位到问题所在，而且添加索引的时间肯定是远大于初始添加索引所需要的时间，可见索引的添加也是非常有技术含量的。  
 
 ### 索引相关的数据结构和算法
 通常我们所说的索引是指B-Tree ，它是目前关系型数据库中查找数据最为常用的和有效的索引，大多数存储引擎都支持这种索引。使用B-Tree这个术语，是因为MYSQL 再CREATE TABLE 
 或其他语句中使用了这个关键字，但实际上不同的存储引擎可能使用不同的数据结构，比如InnoDB 就是使用B+Tree。  
 
 B+Tree 中的B 指 balance 意为平衡。需要注意的是，B+树索引并不能找到一个给定的键值的具体行，它找到的只是被查找数行所在的页，接着数据库会把页读入到内存，再在内存中进行查找，
 最后得到要查找的数据。  
 
 在介绍B+Tree 前，先了解一下二叉查找树，它是一种经典的数据结构，其左子树的值总是小于根的值，右子树的值总是大于根的值，如下图①。如果要在这课树中查找值为5的记录，其大致流程：
 先找到根，其值为6，大于5，所以查找左子树，找到3，而5大于3，接着找3的右子树，总共找了3次。同样的方法，如果查找值为8的记录，也需要查找3次。所以二叉查找树的平均查找次数为(
 3 + 3 + 3 + 2 + 2 + 1) / 6 = 2.3次，而顺序查找的话，查找值为2的记录，仅需要1次，但查找值为8的记录则需要6次，所以顺序查找的平均查找次数为：(1 + 2 + 3 + 4 + 5 + 6) / 6 = 3.3次，
 因此大多数情况下二叉查找树的平均查找速度比顺序查找要快。  
 
 ### 二叉查找树和平衡二叉树  
 由于二叉查找树可以任意构造，同样的值，可以构造出 如图（2）的二叉查找树，显然这颗二叉树的查询效率和顺序差不多。若想二叉查找树的查询性能最高，需要这颗二叉查找树是平衡的，也即平衡二叉树（AVL树 ）  
 
 平衡二叉树首先需要符合二叉查找树的定义，其次必须满足任何节点的两个子树的高度差不能大于1，显然（2）不能满足平衡二叉树的定义。而图（1）是一颗平衡二叉树，平衡二叉树的查找性能是比较高的
 （性能最好的是最优二叉树），查询性能越好，维护的成本就越大，比如图（1）的平衡二叉树，当用户需要插入一个新的值9的节点时，据需要做出如下的变动。
 
 平衡二叉树旋转  
 通过一次左旋操作就将插入后的树重新变为平衡二叉树时最简单的情况了，实际应用场景中可能需要旋转多次，至此我们可以考虑一个问题，平衡二叉树的查找效率还不错，实现也非常简单，相应的维护成本还能接受，为什么MySQL索引不直接使用平衡二叉树？  
 
 随着数据库中数据的增加，索引本身大小随之增加，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级。可以想象一下一棵几百万节点的二叉树的深度是多少？
 如果将这么大深度的一颗二叉树放磁盘上，每读取一个节点，需要一次磁盘的I/O读取，整个查找的耗时显然是不能够接受的。那么如何减少查找过程中的I/O存取次数？  
 
 一种行之有效的解决方法是减少树的深度，将二叉树变为m叉树（多路搜索树），而B+Tree就是一种多路搜索树。理解B+Tree时，只需要理解其最重要的两个特征即可：第一，所有的关键字（可以理解为数据）都存储在叶子节点（Leaf Page），非叶子节点（Index Page）并不存储真正的数据，
 所有记录节点都是按键值大小顺序存放在同一层叶子节点上。其次，所有的叶子节点由指针连接。如下图为高度为2的简化了的B+Tree。  
 
 简化B+Tree
 
 怎么理解这两个特征？MySQL将每个节点的大小设置为一个页的整数倍（原因下文会介绍），也就是在节点空间大小一定的情况下，每个节点可以存储更多的内结点，这样每个结点能索引的范围更大更精确。所有的叶子节点使用指针链接的好处是可以进行区间访问，比如上图中，
 如果查找大于20而小于30的记录，只需要找到节点20，就可以遍历指针依次找到25、30。如果没有链接指针的话，就无法进行区间查找。这也是MySQL使用B+Tree作为索引存储结构的重要原因。  
 
 MySQL为何将节点大小设置为页的整数倍，这就需要理解磁盘的存储原理。磁盘本身存取就比主存慢很多，在加上机械运动损耗（特别是
 普通的机械硬盘），磁盘的存取速度往往是主存的几百万分之一，为了尽量减少磁盘I/O，磁盘往往不是严格按需读取，而是每次都会预
 读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存，预读的长度一般为页的整数倍。  
 
 页是计算机管理存储器的逻辑块，硬件及OS往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（许多OS中，页的
 大小通常为4K）。主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读
 盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后一起返回，程序继续运行。  
 
 MySQL巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，
 每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实
 现了读取一个节点只需一次I/O。假设B+Tree的高度为h，一次检索最多需要h-1次I/O（根节点常驻内存），复杂度O(h) = O(logmN)。实
 际应用场景中，M通常较大，常常超过100，因此树的高度一般都比较小，通常不超过3。  
 最后简单了解下B+Tree节点的操作，在整体上对索引的维护有一个大概的了解，虽然索引可以大大提高查询效率，但维护索引仍要花费
 很大的代价，因此合理的创建索引也就尤为重要。  
 
 仍以上面的树为例，我们假设每个节点只能存储4个内节点。首先要插入第一个节点28，如下图所示。  
 
 leaf page和index page都没有满  
 
 接着插入下一个节点70，在Index Page中查询后得知应该插入到50 - 70之间的叶子节点，但叶子节点已满，这时候就需要进行也分裂的
 操作，当前的叶子节点起点为50，所以根据中间值来拆分叶子节点，如下图所示。  
 
 Leaf Page拆分  
 
 最后插入一个节点95，这时候Index Page和Leaf Page都满了，就需要做两次拆分，如下图所示。  
 
 Leaf Page与Index Page拆分  
 拆分后最终形成这样一棵树  
 
 B+Tree为了保持平衡，对于新插入的值需要做大量的拆分页操作，而页的拆分需要I/O操作，为了尽可能的减少页的拆分操作，B+Tree也
 提供了类似于平衡二叉树的旋转功能。当Leaf Page已满但其左右兄弟节点没有满的情况下，B+Tree并不急于去做拆分操作，而是将记录
 移到当前所在页的兄弟节点上。通常情况下，左兄弟会被先检查用来做旋转操作。就比如上面第二个示例，当插入70的时候，并不会去做
 页拆分，而是左旋操作。  
 
 通过旋转操作可以最大限度的减少页分裂，从而减少索引维护过程中的磁盘的I/O操作，也提高索引维护效率。需要注意的是，删除节点
 跟插入节点类似，仍然需要旋转和拆分操作，这里就不再说明。  
 
 
## 高性能策略  
通过上文，我们对于B+tree 的数据结构已经有了大致的了解，但是MYSQL 中索引是如何组织数据的存储呢？以一个简单的示例来说明：

    create table People(
      last_name varchar(50) not null;
      first_name varchar(50) not nulll,
      dob date not null,
      gender enum('m','f') not null,
      key(last_name,first_name,dob)  
    );

对于表中每一行数据，索引中包含了 last_name,first_name,dob 列的值，下图展示了索引是如何组织数据存储的。  

可以看到，索引首先根据第一个字段来排列顺序，当名字相同时，则根据第三个字段，即出生日期来排序，正式因为这个原因，才有了索引的
最左原则。  

## mysql 不会使用索引的情况：非独立的列
 独立的列 是指索引列不能是表达式的一部分，也不能是函数的参数：比如：
 
    select * form where id + 1 = 5;

我们很容易看出其等价于id = 4，但是MYSQL 无法自动解析这个表达式，使用函数是同样的道理。  

## 前缀索引  

如果列很长，通常可以索引开始的部分字符，这样可以有效节约索引空间，从而提高索引效率。  

### 多列索引和索引顺序
 在多数情况下，在多个列上建立独立的索引并不能提高查询性能，理由非常简单，MYSQL 不知道选择拿分索引的擦汗寻效率会更好，所以
 在老版本，比如MYSQL 5.0 之前就会随便选择一个列的索引，而新的版本会采用合并索引的策略，举个简单的例子，在一张电影演员表中，
 在actor_id 和 film_id 两个列上都剪了独立的索引，然后又如下查询：
 
    select file_id,acotr_id from file_actor where actor_id = 1 or film_id = 1;
 
老版本的MYSQL 会随机选择一个索引，但是新版本做如下的优化：

    select fil_id,actor_id form film_actor where actor_id =1
    union all
    select file_id,actor_id form file_Actor where film_id = 1 and actor_id <> 1;
  
当出现多个索引做相交操作时多个AND条件，通常来说一个包含所有相关列的索引又优先于多个独立索引。  

当出现多个索引做联合操作时（多个OR条件），对结果集的合并、排序等操作需要耗费大量的CPU和内存资源，特别时当其中的某些索引的
选择性不高，需要返回合并大量数据时，查询成本更高，所以这种情况下还不如走全表扫描。  

因此explain 时 如果发又索引合并（Extra字段出现Using union）,因该好好检查以下查询和表结果是不是已经最优的，如果查询和表都没有问题，
那只能说明索引创建的很糟糕，应当慎重考虑索引是否合适，有可能一个包含所有相关列的所列索引更适合。  

前面我们提到过索引时如何组织数据存储的，从图可以看到多列索引时，索引的顺序对于查询时至关重要的，很明显应该把选择性更高的字段
放到索引的前面，这样通过第一个字段就可以过滤掉大多数不符合条件的数据。  

索引选择性是指不重复的索引值和数据表的总记录数的壁纸，选择性越高查询效率越高，因为选择性越高的索引可以让MYSQL 在查询时过滤
掉更多的行，唯一索引的选择性是1，这是最好的索引选择性，性能是最好的。  

理解索引选择性的概念后，就不难确定哪个字段的选择性较高了，查一下就知道了，比如：

    select * from payment where staff_id =2 and customer_id = 584

是应该创建 （staff_id , customer_id）的索引还是应该颠倒以下顺序？执行下面的查询，哪个字段的选择性更加接近1就把哪个字段索引
前面就好  

    select count(distinct staff_id)/count(*) as staff_id_selectivity,
            count(distinct customer_id)/count(*) as customer_id_selectivity,
            count(8) form payment

多数情况下使用这个原则没有任何问题，但是仍然注意你的数据中是否存在一些特殊情况，举个简单的例子，比如要查询某个用户组下有过
交易的用户信息：
    
    select user_id form trade where user_group_id = 1 and trade_amount > 0;
 
MYSQL 为这个查询选择了索引（user_group_id.trade_amount），如果不考虑特殊情况，这看起来没有问题，但实际情况是这张表的大多数
数据都是从老系统中迁移过来的，由于新系统的数据不兼容，所以就给老系统迁移过来的数据赋予了一个默认的用户组。这种情况下，通过
索引扫描的行数 跟全表扫描基本没有什么区别，索引也就起不到任何作用了。  

## 避免多个范围条件
实际开发中，我们会经常使用多个范围条件，比如想查询某个时间段内登陆过的用户：

    select user.* from user where login_time > "2019-02-15" and age between 18 and 30;
    
这个查询有一个问题，它有两个范围条件，login_time列和 age 列，MYSQL 可以使用 login_time列的索引 或者age 列的索引，使无法同时
使用他们。  

## 覆盖索引  
如果一个索引包含或者覆盖所有需要查询的字段的值，那么就没有必要再回表查询，这就称为覆盖索引，覆盖索引是非常有用的工具，那么就没有
必要再回表查询，这就称为覆盖索引，覆盖索引是非常有用的工具，可以极大的提高性能，因为查询只需要扫描索引回带来许多好处。  

索引条目远小于数据行大小，如果只读取 索引，极大减少数据访问量。  

索引是有按照列值顺序存储的，对于I/O密集型的范围查询要比随机从磁盘读取每一行数据的IO要少的多。  

## 使用索引扫描来排序  
MYSQL 有两种方式可以生产有序的结果集，其一是对结果集进行排序操作，其二是按照索引顺序扫描得出的结果自然是有序的，如果explain 的结果中
type 列的值，为index 表示使用了索引扫描来做排序。  

扫描索引本身很快，因为只需要从一条索引记录移动到相邻的下一条记录。但如果索引本身不能覆盖所有需要查询的列，那么就不得不每扫描
一条索引记录就回表查询一次对应的行，这个读取操作基本上是随机I/O，因此按照索引顺序读取数据的速度通常要顺序地全表扫描要慢。  

在设计索引时，如果一个索引既能够满足排序，又满足查询，是最好地。  

只有当索引地 列顺序和ORDER BY子句地顺序完全一致，并且所有列地排序方向也一样时，才能够使用索引来对结果做排序  
 
只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向也一样时，才能够使用索引来对结果做排序。如果查询需要
关联多张表，则只有ORDER BY子句引用的字段全部为第一张表时，才能使用索引做排序。ORDER BY子句和查询的限制是一样的，都要满足
最左前缀的要求（有一种情况例外，就是最左的列被指定为常数，下面是一个简单的示例），其他情况下都需要执行排序操作，而无法利
用索引排序。

    // 最左列为常数，索引：(date,staff_id,customer_id)
    select  staff_id,customer_id from demo where date = '2015-06-01' order by staff_id,customer_id

## 冗余和重复索引  
冗余索引是指在相同地列上按照相同地顺序创建地相同类型地索引，应当尽量避免这种索引，发现后立即删除。比如有一个索引（A,B），
在创建索引（A）就是冗余索引，冗余索引经常发生在为表添加新索引时，比如有人创建了索引（A,B），但这个索引不是扩展已经有了地索引(A)  

大多数情况下都应该尽量扩展已有地索引而不是创建新索引，但是有极少情况下出现性能方面地考虑需要冗余索引，比如扩展已有索引而
导致其变得过大，从而影响到其他使用该索引地查询。  

## 删除长期未使用的索引  
定期删除一些长时间未使用过地索引是一个非常好地习惯。  

## 特定类型查询优化

COUNT() 它有两种不同地作用，其一是统计某个列值地数量，其二是统计行数，统计列值时，要求列值是空的，他不会统计NULL，如果确认
括号中地表达式不可能为空时，实际上就是在统计行数，最简单地就是当使用 COUNT(*)的时候，并不是我们所想的那样扩展所有的列，实际上，
他会忽略所有的列而直接统计行数。  

我们最常见的误解也就在这，在括号内指定了一列希望统计结果是行数，而且还常常误以为前者的性能会更好，但实际并非这样，如果要
统计行数，直接使用 COUNT(*),意义清洗，且性能更好。  

有时候某些业务场景并不需要完全精确的COUNT 值，可以用近似来代替，EXPLAIN 出来的行数就是一个不错的近似值，而且执行EXPLAIN 并
不需要真正地去执行擦汗寻，所以成本非常低，通常来说，执行COUNT()都需要扫描大量地行才能获取精确地数据，因此很难优化，MYSQL层面
还能做得也就只有覆盖索引了，如果还不能解决问题，只有从架构层面解决了，比如添加汇总表，或者使用redis这样地外部缓存系统。  


## 优化关联查询  
在大数据场景下，表与表之间通过一个冗余字段来关联，要比直接使用JOIN有更好的性能，如果确实需要使用关联查询地情况下，需要特别
注意地是：  

确保ON和USING 字句中地列上有索引，在创建索引地时候就要考虑到关联地顺序，当表A和表B 用列C关联地时候，，如果优化器关联的顺序
是A \ B ,那么就不需要再A地对应列上创建索引。没有用到地索引会带来额外地负担，一般来说，除非有其他理由，只需要在关联顺序中的
第二张表的相应列上创建索引。  

确保任何的GROUP BY 和 ORDER BY 中的表达式只涉及到一个表中的列，这样MYSQL 才有可能使用索引来优化。  

要理解优化关联查询的第一个技巧，就需要理解MYSQL 是如何执行关联查询的，当前MYSQL 关联执行的策略非常简单，它对任何的关联都执行
嵌套循环关联操作，即先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行
为止。然后根据各个表匹配的行，返回查询中需要的各个列。  

例如：
    
    SELECT A.xx,B.yy 
    FROM A INNER JOIN B USING(c)
    WHERE A.xx IN (5,6)
    
假设MYSQL 按照查询中的关联顺序 A、B 来进行关联操作，那么可以用下面的伪代码表示MYSQL 如何完成这个查询的。  

    outer_iterator = SELECT A.xx,A.c FROM A WHERE A.xx IN (5,6);
    outer_row = outer_iterator.next;
    while(outer_row) {
       inner_iterator = SELECT B.yy FROM B WHERE B.c = outer_row.c;
       inner_row = inner_iterator.next;
       while(inner_row) {
           output[inner_row.yy,outer_row.xx];
           inner_row = inner_iterator.next;
       }
       outer_row = outer_iterator.next;
    }

可以看到，最外层的查询是根据 A.xx 列来查询的，A.c 上如果有索引的话，整个关联查询也不会使用，再看内层的拆线呢，很明显 B.c
上如果有索引的话，能够加速查询，因此之u需要再关联顺序中的第二张表的相应列上创建索引即可。   

## 优化LIMIT 分页
当需要分页操作时，通常会使用LIMIT 加上偏移量的办法实现，同时加上合适的ORDER BY字句，如果有对应的索引，通常效率会不错，否则，MYSQL
需要做大量的文件排序操作。  

一个常见的问题是当偏移量非常大的时候 ，比如：LIMIT 1000 20 这样的查询，MYSQL需要查询10020条记录然后只返回20条记录，前面的10000条记录
都将被抛弃，这样的代价非常高。  

优化这种查询一个最简单的办法就是尽可能地使用覆盖索引扫描，而不是查询所有地列。然后根据需要做一次关联查询再返回所有地列。对于偏移量
很大时，这样做地效率会提升非常大，考虑下面地查询：  

    select film_id,description from film ORDER BY title LIMIT 50,5;
   
如果这张表非常大，那么这个查询最好改成下面地样子：  

    SELECT film.film_id,film.desciption
    FROM film INNER JOIN(
        select film_id FRON film ORDER BY title LIMIT 50,5
    ) AS tmp USING(film_id);

这里地延迟关联讲大大提升查询效率，让MYSQL 扫描尽可能少地页面，获取需要访问地记录后在根据关联列回原表查询所需要地列。  

有时候如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用OFFSET，比如下面的查询：  

    SELECT id FROM t LIMIT 10000.10;
    改为： 
    SELECT id FROM t WHERE id > 10000 LIMIT 10;
 
 其他优化的办法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表中只包含主键列和需要做排序的列。  
 
 ## 优化UNION 
 MYSQL 处理UNION的策略是先创建临时表，然后再把各个查询结果插入到临时表中，最后再来做查询。因此很多优化策略再UNION查询中
 都没有办法很好的时候。经常需要手动将WHERE \LIMIT\ORDER BY 等字句 下推 到各个子查询中，以便优化器可以充分利用这些条件先优化。  
 
 除非确实 需要服务器去重，否则就一定要使用UNION ALL，如果没有ALL关键字，MYSQL会给来临时表加上DISTINCT选项，这会导致整个临时表
 的数据做唯一性检查，这样做的代价非常高，当然即使使用ALL关键字，MYSQL 总是将结果放入临时表，然后再独处，再返回给客户端。虽然很多
 时候没有整个必要，比如有时候可以直接把每个子查询的结果返回给客户端。  
 
 ##结语
 理解查询时如何执行以及时间都消耗再哪些地方，再加上一些优化过程的知识，可以帮助大家更好的理解MYSQL，理解常见优化技巧的背后的原理。   
 
 